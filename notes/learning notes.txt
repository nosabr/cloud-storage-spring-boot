SOLID:
1. SRP - Solid Responsibility Principle
    Ось изменений, через один класс проходит только одна ось изменений.
    Один класс отвечает только за одно действие
2. Open Closed Principle
    Открыт к изменениям
    Легко добавлять новый функционал, не изменяя старого
    Удобно для тестировщиков, им не нужно рекурсивно проводить тесты нового функционала
    Расширение с помощью наследования, старый код можно менять только при багфиксе

    Полиформный принцип Открытости Закрытости
    Клиентский код зависит от интерфейса, который не изменяется
    Новая реализация реализует тот самый интерфейс, делегирует или наследует старую реализацию,
    тем самым клиентский код не меняется, это принцип Роберта Мартина
    По другому называется Protected variations
    Клиентский код -> Интерфейс серверного <- Сервеный код

3. Liscov Substitution Principle
    поведение в наследующих классах не должно противоречить родительскому классу
    Если Б наследуется от А, то Б должен выполнять все методы из А без выкидывание экзепшенов и
    создании других проблем
    Квадрат наследуется от четырехугольника, но у квадрата только одна сторона, а у четерых две стороны
    При тесте четырех угольников и квадрата и помещение туда двух параметров, у квадрата могут все упасть, т
    так как нет второй стороны
    Подкласс не должен вызывать больше чем базовый класс, и меньше чем базовый класс
    Клиентский код не должен знать что это конкретный подкласс, и должен что то делать прежде вызова этого подкласса
    проверять что это точно тот самый подкласс, делать instance of плохая практика, НИКОГДА НЕ ВОЗВРАЩАТЬ NULL

4. Interface Segregation Principle
    Если клиент не использует некоторые методы интерфейса, то изменения этого метода не должны изменять код клиента
    если есть один интерфейс, и класс имплементирует этот интерфейс, то класс должен выполнять все методы интерфейса

5. Dependency Inversion Principle
    Сущность более высокого уровня не должны зависеть от кода более низкого уровня
